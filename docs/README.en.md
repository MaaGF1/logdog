[![Run](https://img.shields.io/badge/Download%20and%20Run-8CA1AF?logo=readthedocs&logoColor=fff)](01_begin.en.md)

# MaaFramework Watchdog

A log-based monitoring system designed for MaaFramework.

Logdog monitors MaaFramework Pipeline execution flow by analyzing log files in real-time. It uses a configurable graph-based state machine to track task node transitions, detect timeouts, and send alerts via external notifications when operations fail to complete within expected timeframes.

## 1. Features

* Non-intrusive monitoring: Monitors agents through `debug/maa.log` file without process memory injection.
* Graph-based State Machine: Supports single-state multi-branch logic, automatically merging rules sharing the same start node (e.g., `Start -> Branch A` or `Start -> Branch B`).
* Smart Timeout Detection: Dynamically calculates the minimum timeout threshold based on all potential outgoing edges of the current node.
* Entry node detection: Automatically resets currently active states when a new task cycle begins (entry node) to prevent logic errors.
* Multi-platform notifications: 
    * Telegram Bot
    * WeChat Work
* Custom alerts: Filter event types that trigger notifications, e.g.: alert only when timeouts occur.
* Custom action:
    * External notifications
    * Auto shutdown

## 2. Using Source Code

Requires Python 3.8 or above.

1. Clone the repository: 

```bash
git clone git@github.com:MaaGF1/logdog.git
# or
git clone https://github.com/MaaGF1/logdog.git
# Enter directory
cd logdog
```

2. Install dependencies: 

The only external dependency is the `requests` library for sending notifications: 

```bash
pip install requests
```

3. Build C++ Core:

The core logic is implemented in C++ and requires `scons` to build. Ensure a C++ compiler and SCons are installed.

```bash
scons
```

## 3. Configuration

The system is fully controlled through the `watchdog.conf` file.

### 3.1 Notification Settings

Configure external notification parameters and set notification filter options.

```ini
[Notification]
# Telegram configuration
Bot_Token=123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11
Chat_ID=123456789

# WeChat Work configuration
Webhook_Key=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx

# Default platform, available options: 
    # telegram
    # wechat
Default_ExtNotify=wechat

# Notification filter, defines which events trigger message sending, available options: 
    # StateActivated (state activated), 
    # StateCompleted (state completed), 
    # Timeout (timeout), 
    # StateInterrupted (state interrupted), 
    # EntryDetected (entry detected)
# If this line is commented out, all events will be sent.
NotifyWhen={Timeout, StateInterrupted}
```

### 3.2 Monitoring Settings

Point Watchdog to your MaaFramework log file.

```ini
[Monitoring]
# Path to log file generated by MaaFramework
Log_File_Path=../debug/maa.log

# Polling interval (seconds)
Monitor_Interval=1.0
```

### 3.3 State Machine Rules

#### State Rules (`[States]`)
Format: `RuleName={StartNode, TimeoutMS, NextNode, [TimeoutMS, NextNode...], Description}`

The system parses all rules into a state graph. If multiple rules start with the same node, they are treated as different branches from that node.

* StartNode: The name of the node currently active.
* TimeoutMS: Allowed time to reach the next node. **Note: If a node has multiple branches, the system uses the minimum timeout among all branches as the threshold.**
* NextNode: The expected target node.

```ini
[States]
# Simple linear rule: StartTask -> (30s) -> EndTask
Simple_Task={StartTask, 30000, EndTask, "Basic task monitoring"}

# Branching logic example:
# When at 'DecisionNode', if 'BranchA' is detected within 10s, take path A;
# If 'BranchB' is detected, take path B.
# If neither A nor B appears within 10s, a timeout is triggered.
Flow_Path_A={DecisionNode, 10000, BranchA, "Flow Path A"}
Flow_Path_B={DecisionNode, 10000, BranchB, "Flow Path B"}
```

#### Entry Nodes (`[Entries]`)

Nodes that mark the beginning of major workflows. When such nodes are detected, the state machine performs a hard reset and starts tracking from this node. This handles unexpected restarts or manual interventions.

```ini
[Entries]
# Format: Name={NodeName, Description}
Main_Entry={Task_Start_Node, "Main task entry point"}
```

#### Completion Nodes (`[Completed]`)

Nodes that explicitly mark the process as successfully finished. Upon reaching this node, the state machine stops the timer and resets the state.

```ini
[Completed]
# Format: Name={NodeName, Description}
Task_Done={Task_Success_Node, "Task completed successfully"}
```

## 4. Usage

### 4.1 Starting Watchdog

Run the main script. It will block and monitor the log file indefinitely.

```bash
# Ensure scons build is complete
python main.py
```

### 4.2 Command Line Arguments

* `--config <path>`: Specify custom configuration file path.
* `--status`: Print current configuration summary and exit.

Example:

```bash
python main.py --config ./my_configs/watchdog.conf
```

## 5. How it works

1. **Log Parsing**: The C++ core reads `maa.log` in real-time, extracting nodes via regex patterns like `[pipeline_data.name=NodeName] | enter`.
2. **State Transition**: 
    * The system maintains a single "Current Node" pointer.
    * When a new node is detected, the system checks if it is a valid "Next Hop" from the current node (based on configured rules).
    * If matched, the system updates the "Current Node" and resets the timer.
3. **Timeout Mechanism**: 
    * Upon entering a new node, the system calculates the **shortest** timeout among all possible outgoing paths.
    * If no valid transition occurs within this time limit, a `Timeout` event is triggered.
4. **Notification**: The Python layer receives events from C++ and sends alerts to configured platforms based on `NotifyWhen` settings.