#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <chrono>
#include <memory>
#include <limits>

namespace logdog {

// Represents an edge in the state graph
struct GraphEdge {
    std::string target_node;
    int timeout_ms;
    std::string rule_name;   // The rule name this transition belongs to
    std::string description; // Description of the rule
};

// Configuration input structure (kept for compatibility with Engine)
struct StateConfig {
    std::string name;
    std::string start_node;
    std::vector<std::pair<std::string, int>> transitions; // target, timeout
    std::string description;
};

// Event types to send back to Python
enum class EventType {
    StateActivated,
    StateCompleted,
    Timeout,
    StateInterrupted,
    EntryDetected,
    EngineLog
};

struct EventData {
    EventType type;
    std::string state_name;
    std::string node_name;
    std::string description;
    int elapsed_ms;
};

class StateMachine {
public:
    StateMachine();
    
    // Parses linear config into graph edges
    void add_state_config(const StateConfig& config);
    
    void set_completion_nodes(const std::unordered_set<std::string>& nodes);
    void add_entry_node(const std::string& node_name, const std::string& name, const std::string& desc);

    // Returns a list of events generated by this node processing
    std::vector<EventData> process_node(const std::string& node_name);
    
    // Check timeouts based on current node
    std::vector<EventData> check_timeouts();

private:
    // Graph: Source Node -> List of possible transitions
    std::unordered_map<std::string, std::vector<GraphEdge>> adjacency_list_;
    
    // Global settings
    std::unordered_set<std::string> completion_nodes_;
    struct EntryInfo { std::string name; std::string desc; };
    std::unordered_map<std::string, EntryInfo> entry_nodes_;

    // Runtime State (Single State Model)
    std::string current_node_;
    std::chrono::steady_clock::time_point last_transition_time_;
    bool is_active_; 
    int current_timeout_threshold_; // The minimum timeout of all outgoing edges

    // Helpers
    void reset_state();
    void transition_to(const std::string& node_name, const std::chrono::steady_clock::time_point& now);
    int calculate_min_timeout(const std::string& node_name);
};

} // namespace logdog